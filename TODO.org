#+TITLE: Security Analysis for Autonomous Agent Execution
#+DESCRIPTION: Practical security assessment - what actually matters vs security theater

* Tasks
** DONE Set default Codex reasoning effort in generated project config
** TODO Add shared per-project multi-agent memory + per-agent personal memory
** TODO Tmux copy/paste broken over mosh (works over ssh)
   Might be mosh not supporting OSC 52. Wayland/Sway relevance unclear.
** TODO Send agent findings via email (or similar async channel)
** TODO Generated projects should include a stub HTTP service with hot reload (including browser reload)
   Per-project scaffolding target (SOTA defaults):
   - TypeScript: Vite dev server with native HMR
   - Python: FastAPI + =uvicorn --reload= + browser live reload bridge
   - Go: net/http + =air= + browser live reload bridge
   - Rust: HTTP starter + watcher-based restart + browser live reload bridge
   - Other/Shell: static + live reload baseline

   Execution plan:
   1. Define a shared dev contract: =just dev= binds =0.0.0.0:$PORT= and serves a browser page
   2. Update language templates and init commands per language
   3. Add generated-project tests for dev files and commands
   4. Run scaffold smoke tests for each language
** TODO Add Phoenix LiveView scaffold support (Elixir)
   Include dev-mode LiveView hot reload and browser live reload defaults.
   Update =Containerfile= to include Elixir/Erlang/Phoenix tooling needed by scaffolded projects.
** DONE Fix mixed-language pre-commit generation dropping prose hooks
   Root cause: prose hooks were skipped unless =languages == ["prose"]=.
   Fix: removed the guard in =_jolo/templates.py= so prose hooks are included
   whenever =prose= is selected.
** TODO Consider adding `jolo exec` command to align with container conventions
** TODO Rebuild container image to pick up notify fixes
   Image is stale — missing: session-ID removal, Click header, Actions header, rename to notify.
   Run: =podman build --build-arg USERNAME=$(whoami) --build-arg USER_ID=$(id -u) --build-arg GROUP_ID=$(id -g) -t emacs-gui .=
** TODO Add ntfy desktop notifications on Linux
   Install =ntfysh-bin= (AUR), configure =~/.config/ntfy/client.yml= to subscribe
   to the =jolo= topic and pipe to =notify-send=, enable =ntfy-client= user service.
   #+begin_src yaml
   subscribe:
     - topic: jolo
       command: 'notify-send -a ntfy "$t" "$m"'
   #+end_src
   #+begin_example
   yay -S ntfysh-bin
   systemctl --user enable --now ntfy-client
   #+end_example
** TODO Format ntfy elapsed time as human-readable (e.g. 7m 2s, 1h 15m)
   Currently shows raw seconds like =(415s)=. Use minutes/hours when applicable.
** TODO Add notification slow-threshold config (default 60s) with local override to 20s
** TODO Research TTS — audio notifications via Kokoro
   :PROPERTIES:
   :BRANCH: feat/research-tts
   :END:

   When =jolo research= completes, generate an mp3 of the full org report via
   Kokoro TTS and attach it to the ntfy notification. Tap play on the phone.

   Code on =feat/research-tts= branch (1 commit ahead of main). Needs image
   rebuild + live testing with Kokoro at =berghome.ts.glvortex.net:4014=.

*** Verification
    1. Rebuild image, restart container
    2. =export KOKORO_URL=http://berghome.ts.glvortex.net:4014=
    3. =jolo research "what is an apple"=
    4. Phone: text notification (instant) + audio (seconds later)
    5. Unset =KOKORO_URL=, verify text-only still works

** TODO Add =--deep= flag to =jolo research=
   Run claude + codex in parallel (both research the same question), wait for both,
   then gemini compiles findings from both files into a synthesis.
   Implementation: single =nohup sh -c= wrapper that backgrounds both researchers,
   =wait=​s, then fires gemini with a compile prompt referencing both org files.
** TODO Redesign =jolo research= — standalone research repo, no worktrees
   :PROPERTIES:
   :BRANCH: feat/jolo-research
   :END:

   Current implementation requires being in a git repo and uses worktrees.
   Redesign: fixed research repo at =~/jolo/research/=, persistent container,
   fire-and-forget agent exec. Works from anywhere.

*** Flow
    #+begin_example
    jolo research "what is an apple"
    #+end_example

    1. =ensure_research_repo(config)= — create =~/jolo/research/= if needed
    2. Start container if not running (=devcontainer up=, idempotent)
    3. Pick agent (=--agent= override or round-robin), generate filename =YYYY-MM-DD-slug.org=
    4. =devcontainer exec= agent in background: =agent -p "/research ..."=
    5. Agent writes file (prompt at top), commits to main, ntfy fires via hook
    6. Print confirmation, return immediately

*** What gets deleted
    - =_spawn_research_watcher()= in commands.py
    - Research mode block in =container/tmux-layout.sh=
    - =.research-mode= flag logic
    - All worktree creation/cleanup in =run_research_mode()=

*** Files to change
    | File                                  | What                                                          |
    |---------------------------------------+---------------------------------------------------------------|
    | =_jolo/constants.py=                  | Add ="research_home": "~/jolo/research"= to DEFAULT_CONFIG    |
    | =_jolo/cli.py=                        | Add =slugify_prompt()=                                        |
    | =_jolo/commands.py=                   | Add =ensure_research_repo()=, rewrite =run_research_mode()=,  |
    |                                       | delete =_spawn_research_watcher()=                            |
    | =_jolo/__init__.py=                   | Update exports                                                |
    | =container/tmux-layout.sh=            | Delete research mode block                                    |
    | =templates/.agents/skills/research/=  | Per-file output support, prompt in file                       |
    | =tests/test_research.py=              | Rewrite for new behavior                                      |

*** =ensure_research_repo(config)=
    - Expand =~/jolo/research/=, return path if =.git= exists
    - =mkdir -p=, =git init=, =scaffold_devcontainer("research", ...)=
    - Copy just the research skill (=.agents/skills/research/=), not full template
    - Initial commit
    - Minimal repo: just org files, devcontainer config, and the research skill

*** =run_research_mode(args)= (rewrite)
    - No =validate_tree_mode()= — call =ensure_research_repo(config)= instead
    - =slugify_prompt(args.prompt)= → filename =YYYY-MM-DD-slug.org=
    - Setup credentials/hooks on the research repo (idempotent)
    - =is_container_running(research_home)=? If not, =devcontainer_up=
    - =devcontainer_exec_command= with backgrounded agent: =nohup agent -p "..." &=
    - Prompt tells agent: write to specific file, include original question

*** Research skill update (=SKILL.md=)
    - If prompt specifies a target filename, write to that file (not =RESEARCH.org=)
    - Standalone file with =#+TITLE:=, =#+PROPERTY: PROMPT=
    - Remove multi-agent append-only language (each file is standalone)

*** Verification
    #+begin_example
    cd /tmp && jolo research "what is an apple"
    # → Research started: claude → 2026-02-11-what-is-an-apple.org
    # Check ~/jolo/research/ for the org file after agent finishes
    #+end_example
** DONE =wt new= should only create 1 tmux window (shell), not the full 5-window layout
   Worktrees are lightweight throwaway branches. Spawning emacs + claude + gemini + codex
   windows per worktree floods the tmux window list. Just a shell is enough.
** TODO Decide whether to add a "safe worktree" default for initial jolo setup (keep main repo untouched)
** DONE Add a shared mounted space between all devcontainers for global resources
   Default mount: ~/stash -> /workspaces/stash (RW, non-reproducible).
** TODO Document Wayland Emacs integration
** TODO Verify tmux-direct terminfo and term-keys in devcontainer
** DONE Add doc-compare skill for narrative version diffs
** DONE Add doc-critique skill for writing feedback
** DONE Alternate agents between external reviews in feature-workflow
** DONE Draft end-user README for Codex (docs/README-codex.org)
** DONE Plan: add `jolo clone <git-url> [dir]` command (devcontainer wrapper)
   - Goal: `jolo clone` clones a repo and immediately brings it up in a devcontainer.
   - Signature: `jolo clone <url> [dir]`
   - Default clone location: `repos/<name>` at workspace root.
   - AGENTS/CLAUDE handling: keep foreign agent files; add top-level guidance in this repo’s AGENTS that cloned repo instructions apply only within that folder.
   - Behavior: should automatically run `jolo up` for the cloned repo after clone.
   - Notes: Beads is installed but cannot be initialized in this worktree.
     - Error: `bd init` fails in worktree; must init in main repo.
     - Required flow:
       1) `cd /workspaces/emacs-container`
       2) `bd init`
       3) `bd worktree create <path> --branch <branch-name>`
     - Reference: https://github.com/steveyegge/beads/blob/main/docs/WORKTREES.md

* Overview

This document analyzes security for running Claude Code in YOLO mode inside containers. The goal: *maximum usability while understanding real risks*.

Guiding principle: If removing access breaks the tool's usefulness, it's not a security improvement - it's just making the tool worse.

* Risk Assessment

** SAFE: GPG Agent Socket

*** Current State
Only the agent socket is mounted, not the private keys:
#+begin_src
pubring.kbx (readonly)    - public keys only
trustdb.gpg (readonly)    - trust database
S.gpg-agent socket        - communication with host agent
#+end_src

*** Status: Already Secure
Private keys *never enter the container*. Agent can request signatures but cannot extract key material. This is the correct design.

Signing commits as the user is *intended behavior* - the user is directing the work.

- [X] No action needed

** FIXED: Claude Configuration (~/.claude)

*** Current State
Selective mounts (readonly):
#+begin_src
~/.claude/.credentials.json (readonly) - auth tokens
~/.claude/settings.json (readonly)     - user preferences
~/.claude/statsig/ (readonly)          - feature flags (subscription, theme)
#+end_src

Excluded (cross-project isolation):
- =projects/= - per-project memory/instructions
- =history.jsonl= - global command history
- =todos/= - todo lists from other projects

*** Security Benefit
- No cross-project instruction injection
- No global history/memory leakage
- Feature flags work (subscription, theme)
- Auth just works (no setup needed)

- [X] Fixed - selective readonly mounts

** INHERENT: API Keys in Environment

*** Current State
#+begin_src
ANTHROPIC_API_KEY, OPENAI_API_KEY
#+end_src

*** Why This Can't Be "Fixed"
No key = no Claude. This is the service, not a container config issue.

- [X] Required for tool to function

** INHERENT: GitHub CLI Configuration

*** Current State
#+begin_src
source=${localEnv:HOME}/.config/gh (readonly)
#+end_src

*** Why This Is Needed
You want to use =gh= commands - that's why it's mounted. The agent doing =gh pr create= is the feature, not a bug.

Already readonly - agent can't modify the config.

- [X] Required for intended workflow

** INHERENT: Network Access

*** Current State
Full network access, ports 4000-5000 forwarded.

*** Why This Is Needed
- Git push/pull
- API calls to Claude
- Package installation (npm, pip, go get)
- Web dev servers

Disabling network makes the tool nearly useless.

- [X] Required for tool to function

** INHERENT: Git Configuration

*** Current State
#+begin_src
source=${localEnv:HOME}/.gitconfig (readonly)
#+end_src

*** Status: Already Secure
Readonly. Needed for git to work (name, email, signing key).

- [X] Already readonly, required for git

** INHERENT: Workspace Access

*** Current State
Full read/write to project directory.

*** This IS The Point
The entire purpose is editing code. Can't sandbox this without making the tool useless.

Review changes with =git diff= before committing - that's the workflow.

- [X] Required - this is the core function

** SAFE: Sudo with Known Password

*** Current State
#+begin_src dockerfile
ARG USER_PASSWORD=dev123
#+end_src

*** Why This Isn't A Real Risk
With rootless Podman: root inside container ≠ root on host.

You *want* sudo to work - installing packages, modifying system files in the container. Agent having sudo inside the container is fine.

- [X] Not a host security risk with rootless containers

** DONE: Shell History

*** Current State
=.histfile= persisted in =.devcontainer/= (per-project, gitignored).

- [X] Per-project history (no cross-contamination)
- [X] In .devcontainer/ which is gitignored

** FIXED: Emacs Configuration

*** Current State
- =start-emacs.sh= uses a sandbox (yadm worktree) - SAFE
- =jolo.py= mounts both config and cache readonly - SAFE

*** Status
- [X] Config mounted readonly
- [X] Cache mounted readonly
- Changes don't affect host

* Summary

| Resource          | Status   | Reason                                    |
|-------------------+----------+-------------------------------------------|
| GPG Socket        | SAFE     | Private keys never exposed                |
| ~/.claude         | FIXED    | Selective readonly (no projects/history)  |
| API Keys          | INHERENT | Required to use the service               |
| GitHub CLI        | INHERENT | You want gh commands to work              |
| Network           | INHERENT | Required for everything                   |
| Git Config        | SAFE     | Already readonly                          |
| Workspace         | INHERENT | This is the entire point                  |
| Sudo              | SAFE     | Rootless container, not a host risk       |
| Shell History     | DONE     | Per-project in .devcontainer/             |
| Emacs Config      | FIXED    | Config and cache both readonly            |

* Actual Recommendations

** For start-emacs.sh users
Already secure - uses sandbox for Emacs config.

** For jolo.py / devcontainer users
- [X] Current setup is secure for directed use
- [X] ~/.claude limited to credentials+settings (readonly)
- [X] ~/.config/emacs is readonly

** For truly unattended autonomous runs
This is a different threat model. If you're letting the agent run for hours unsupervised:
- Review all changes before pushing
- Consider running in a VM instead of container
- But honestly, if you don't trust it unsupervised, don't run it unsupervised

* What Would Actually Be Dangerous (that we're NOT doing)

For reference, things that would be real security problems:
- Mounting =~/.ssh= (private keys) - we don't do this
- Mounting =~/.gnupg/private-keys-v1.d= - we don't do this
- Mounting =~/.password-store= - we don't do this
- Running as root with =--privileged= - we don't do this
- Mounting host root filesystem - we don't do this

The current setup avoids actual dangerous patterns.

* DONE Emacs config isolation improvements

** Mount structure in devcontainer (updated 2026-02)
#+begin_src
~/.config/emacs (container)      <- .devcontainer/.emacs-config/ (copied, writable)
~/.cache/emacs (container)       <- .devcontainer/.emacs-cache/ (fresh per-container)
~/.cache/emacs/elpaca (container)      <- host ~/.cache/emacs-container/elpaca (read-write)
~/.cache/emacs/tree-sitter (container) <- host ~/.cache/emacs-container/tree-sitter (read-write)
#+end_src

** Key: separate cache from host Emacs
Host runs Emacs 31 (glibc/Arch), container runs 30.2 (musl/Alpine).
.elc files and native .so modules are NOT cross-compatible.
=~/.cache/emacs-container/= is a separate persistent cache that elpaca builds
into on first boot. Subsequent boots reuse it.

** DONE Implementation
- [X] Config copied to .devcontainer/.emacs-config/ (writable, isolated)
- [X] elpaca/tree-sitter mounted from ~/.cache/emacs-container/ (read-write, shared)
- [X] setup_emacs_config() creates container cache dirs on host
- [X] Containerfile includes enchant2-dev for jinx-mod.so compilation
- [X] Containerfile includes aspell-en + hunspell-en-us for dictionaries

* DONE Add --mount and --copy options to jolo.py [5/5]

** DONE Add argument parsing for --mount and --copy
- [ ] Add =--mount= argument (action=append for multiple)
- [ ] Add =--copy= argument (action=append for multiple)
- [ ] Both default to empty list =[]= when not provided
- [ ] Test: single --mount, multiple --mount
- [ ] Test: single --copy, multiple --copy
- [ ] Test: --mount and --copy combined

** DONE Implement parse_mount() function
Parse mount argument string into structured data.

*** Syntax
- =source:target= - relative target, read-write
- =source:target:ro= - relative target, read-only
- =source:/absolute/target= - absolute target
- =source:/absolute/target:ro= - absolute target, read-only

*** Logic
- Expand =~= in source path to home directory
- If target starts with =/=, use as-is (absolute)
- If target is relative, prepend =/workspaces/<project>/=
- Default to read-write unless =:ro= suffix
- Return dict: ={source, target, readonly}=

*** Tests
- [ ] Relative target resolves to workspace
- [ ] Absolute target used as-is
- [ ] =:ro= suffix sets readonly=True
- [ ] Default readonly=False
- [ ] Tilde expansion in source

** DONE Implement parse_copy() function
Parse copy argument string into structured data.

*** Syntax
- =source:target= - copy to target path
- =source= - copy to workspace with original basename

*** Logic
- Expand =~= in source path
- If no target specified, use basename of source
- If target is relative, resolve relative to workspace
- If target is absolute, use as-is (but note: only workspace-relative will work)
- Return dict: ={source, target}=

*** Tests
- [ ] With target: resolves correctly
- [ ] Without target: uses basename
- [ ] Relative target resolves to workspace
- [ ] Absolute target used as-is
- [ ] Tilde expansion in source

** DONE Integrate mounts into devcontainer.json generation
- [ ] Create =add_user_mounts()= function (read-modify-write pattern)
- [ ] Format mounts as devcontainer syntax: =source=...,target=...,type=bind[,readonly]=
- [ ] Similar pattern to existing =add_worktree_git_mount()=

*** Persistence behavior
- Mounts added to devcontainer.json persist across restarts
- =--sync= regenerates from BASE_MOUNTS only (clears custom mounts)
- User can manually edit devcontainer.json

*** Tests
- [ ] Mount added to mounts array in JSON
- [ ] Readonly mount includes =readonly= in mount string
- [ ] Multiple mounts all added
- [ ] Verify correct devcontainer mount format

** DONE Implement file copying for --copy
- [ ] Copy files before =devcontainer_up()= is called
- [ ] Handle missing source file (error with clear message)
- [ ] Create parent directories if needed
- [ ] Copied files persist in workspace

*** Integration points
- =run_default_mode()=
- =run_tree_mode()=
- =run_create_mode()=
- =run_init_mode()=

*** Tests
- [ ] File copied to correct location
- [ ] Parent directories created
- [ ] Error on missing source
- [ ] Multiple copies work

** Design decisions

*** Per-invocation vs persistent
- Mounts: persist in devcontainer.json until --sync
- Copies: persist in workspace until deleted

*** Mount syntax mirrors devcontainer
#+begin_example
jolo --mount ~/data:data        # /workspaces/<proj>/data (rw)
jolo --mount ~/data:data:ro     # /workspaces/<proj>/data (ro)
jolo --mount ~/data:/mnt/data   # /mnt/data (rw)
#+end_example

*** Copy syntax similar to mount
#+begin_example
jolo --copy ~/config.json:config/app.json   # /workspaces/<proj>/config/app.json
jolo --copy ~/config.json                   # /workspaces/<proj>/config.json
#+end_example

*** Absolute paths for copy
Copies to absolute paths outside workspace won't work with current approach
(copy happens before container start, workspace is what gets mounted).
Practical restriction: --copy targets should be workspace-relative.

** Test additions for test_jolo.py

*** TestMountArgParsing
- test_mount_flag_single
- test_mount_flag_multiple
- test_mount_default_empty

*** TestMountParsing
- test_parse_mount_relative_target
- test_parse_mount_absolute_target
- test_parse_mount_readonly
- test_parse_mount_expands_tilde
- test_parse_mount_default_readwrite

*** TestCopyArgParsing
- test_copy_flag_single
- test_copy_flag_multiple
- test_copy_default_empty

*** TestCopyParsing
- test_parse_copy_with_target
- test_parse_copy_basename_only
- test_parse_copy_absolute_target
- test_parse_copy_expands_tilde

*** TestMountAndCopyTogether
- test_mount_and_copy_combined

*** TestMountIntegration
- test_add_user_mounts_to_devcontainer_json
- test_mount_readonly_format
- test_multiple_mounts_in_json

* DONE Smart MOTD on every new shell session

Display useful context every time a new tmux pane/window opens (i.e., every new interactive zsh).

** Mechanism
Add a line to =.zshrc.container= (in Containerfile) that runs a motd script.
Every new tmux pane spawns a fresh interactive zsh -> sources .zshrc -> shows motd.

** What to show (dynamic, context-aware)
- Project name (from workspace dir or git remote)
- Git branch + short status
- If justfile exists: =just --list= (the project's available commands)
- If no justfile: container-level info (available tools, tips)
- Port info (=$PORT= value, useful in spawn mode)
- Maybe: last commit summary (one-liner)

** Implementation
- [ ] Create =/usr/local/bin/motd= script in container (or bake into Containerfile)
- [ ] Add =motd= call to =.zshrc.container=
- [ ] Keep output compact - aim for ~5-10 lines max
- [ ] Use color/formatting (gum?) for readability
- [ ] Graceful fallback: if not in a project dir, show generic container info

** Open questions
- Should it suppress in non-interactive contexts? (probably automatic via .zshrc)
- Use =gum= for formatting? (already installed in container)
- Should jolo be able to inject project-specific motd content?

* DONE Prefix container names with project name

Added =--name= to =runArgs= in =build_devcontainer_json()=. Container names in
=podman ps= now match the =name= field: =myapp= for main repo, =myapp-bold-bear=
for worktrees (via =get_container_name()= which already prefixed).

* DONE Rename =jolo switch= to =jolo open=

* DONE Add interactive project switcher to jolo

Implemented as =jolo open=. Uses fzf > gum > numbered fallback.
Filters out orphan containers (missing workspace dir). Skips picker
when only one container is running.

** Requirements
- [X] =jolo open= lists all active/running jolo projects
- [X] Display useful info per project (name, status, worktree, port, container state)
- [X] Interactive selection to switch into the chosen project's container
- [X] Reuse existing =--list= discovery logic for finding active projects

** Design decisions
- Selection UI: fzf > gum > numbered fallback
- "Switch" means: tmux attach into the selected container
- Only show running containers (stopped ones aren't switchable)
- Orphan containers (workspace dir deleted) silently filtered out
- =jolo prune= cleans up orphan containers

* DONE Agent Skills open standard with =.agents/skills/=

Implemented the Agent Skills open standard. Skills live in =.agents/skills/<name>/SKILL.md=
with YAML frontmatter (name, description). Agent-specific directories use symlinks:
- =.claude/skills= -> =../.agents/skills=
- =.gemini/skills= -> =../.agents/skills=

This way skills are written once and discovered by any agent that supports the convention.

** Skills included
- =/afk= — autonomous multi-branch work while user is away
- =/db-reset= — detect and reset local dev database
- =/deploy-preview= — build, test, push preview branch, create draft PR
- =/new-worktree= — create git worktree + devcontainer with naming conventions
- =/scaffold-api= — scaffold FastAPI or Elysia API project
- =/scaffold-web= — scaffold Vite + Tailwind frontend project
- =/sync-dotfiles= — sync yadm dotfiles into container Emacs sandbox

** Structure
#+begin_example
.agents/skills/<name>/SKILL.md   # canonical location
.claude/skills -> ../.agents/skills  # Claude Code symlink
.gemini/skills -> ../.agents/skills  # Gemini CLI symlink
templates/.agents/skills/.gitkeep    # scaffolded into new projects
templates/.claude/skills -> symlink  # scaffolded into new projects
templates/.gemini/skills -> symlink  # scaffolded into new projects
#+end_example

* DONE Unified =jolo delete= — worktree and project removal

Replaced separate =jolo delete= (worktrees only) and =jolo destroy= (projects only)
with a single =jolo delete= that handles both. =jolo destroy= removed.

** What was built
- [X] =jolo delete= — interactive picker showing all projects and worktrees globally
- [X] =jolo delete <name>= — delete worktree by name in current project
- [X] =jolo delete <path>= — delete project by path (starts with =.= or =/=)
- [X] =--purge= flag to also remove directories from disk
- [X] =--yes= / =-y= to skip confirmation prompts
- [X] Interactive selection via fzf > numbered fallback
- [X] Confirmation before each destructive action
- [X] If project has worktrees, prompts to delete them too

** Also fixed
- [X] Worktree port conflicts: new worktrees get fresh random port instead of copying main project's
- [X] Per-command CLI flags: each subcommand only shows its relevant flags in =--help=

* DONE Tmux session layout — auto-start emacs + AI agents (tmuxinator-style)

Uses tmuxinator (=apk add tmuxinator=, pulls in Ruby) with =container/dev.yml=.
Layout script =container/tmux-layout.sh= handles reattach and prompt mode.

** Layout (5 windows, base-index 1)
- Window 1: Emacs (=e=)
- Window 2: Claude Code (=claude --dangerously-skip-permissions=)
- Window 3: Gemini CLI (=gemini --yolo=)
- Window 4: Codex CLI (=codex=)
- Window 5: Spare shell

** Prompt mode
=jolo start -p "..."= writes =.devcontainer/.agent-prompt= and =.agent-name=
before =devcontainer_up()=. =tmux-layout.sh= reads these, patches the
tmuxinator config, and focuses the prompted agent's window.

** Implementation
- [X] =container/dev.yml= — tmuxinator config
- [X] =container/tmux-layout.sh= — wrapper (reattach + prompt)
- [X] =Containerfile= — ruby, tmuxinator, base-index 1, COPY files
- [X] =entrypoint.sh= — =sleep infinity= (devcontainer exec handles tmux)
- [X] =jolo.py= — =write_prompt_file()=, fallback in =devcontainer_exec_tmux()=
- [X] =templates/.gitignore= — =.agent-prompt=, =.agent-name=

* DONE Add a justfile for the jolo meta-project

Already in place with recipes: =test=, =test-k=, =test-v=, =lint=, =lint-fix=,
=fmt=, =fmt-check=, =check= (all three), =build= (container image).

* DONE Coding style conventions for AI agents

Added "Coding Style" section to =templates/AGENTS.md= so every =jolo create=
project gets it. Covers: functional style, strict types, short-but-clear naming,
file size guidelines, language-idiomatic error handling, self-documenting code,
balanced testing, dependency philosophy, and anti-patterns to avoid.

* DONE Tmux copy to host clipboard does not work

Two problems found and fixed:

1. *Host tmux.conf overrides container's* — =BASE_MOUNTS= bind-mounts the host's
   =~/.tmux.conf= (readonly) over the container's, so the Containerfile's clipboard
   settings were silently lost.

2. *=copy-command "wl-copy"= is wrong for containers* — =wl-copy= requires a working
   Wayland connection. In terminal-only jolo devcontainers, Wayland is unreliable.
   OSC 52 (=set -s set-clipboard on=) is the correct mechanism: tmux emits escape
   sequences that the host terminal interprets and copies to the system clipboard.

** Fix
- Added =/etc/tmux.conf= with =set -s set-clipboard on=. The system-wide config is
  loaded *in addition to* the user config, so it survives the host's =~/.tmux.conf=
  being mounted over the container's.
- Removed =copy-command "wl-copy"= from the Containerfile's =~/.tmux.conf=.
  OSC 52 handles clipboard transfer without needing Wayland access.

* DONE Add template metadata placeholders

- Added =Generated: <YYYY-MM-DD>= to =templates/AGENTS.md=.
- Added =#+DATE: <YYYY-MM-DD>= to =templates/TODO.org=.

* DONE Add podman image/storage cleanup to =jolo prune=

=jolo prune= only removes stopped containers and stale worktrees. It never
cleans up unused devcontainer *images* or ID-mapped layer copies, which
accumulate and eventually cause "no space left on device" even with free
disk space.

** Problem

- Devcontainer CLI creates images named =vsc-{workspace}-{hash}[-uid]=
- =--userns=keep-id= (podman) creates ID-mapped copies of every layer,
  roughly doubling storage per image
- Old images from rebuilt/deleted projects persist forever
- =jolo prune= has no concept of image cleanup

** Scope: only jolo-managed resources

We must NEVER remove unrelated podman images/containers. Only clean up
resources that we can trace back to jolo-managed projects.

** Approach: cross-reference containers with images

*** Step 1: Identify jolo containers (already done)

Containers with =devcontainer.local_folder= label are devcontainer-managed.
=list_all_devcontainers()= already queries these.

*** Step 2: Identify images used by jolo containers

For each known devcontainer container (running or stopped), get its image ID.
These are the images we "own". Use:
#+begin_src
podman ps -a --filter label=devcontainer.local_folder --format '{{.ImageID}}\t{{.Image}}\t{{.State}}'
#+end_src

*** Step 3: Determine which images are removable

An image is removable if:
- It belongs to a stopped container that we're pruning, AND
- No running container uses the same image

*** Step 4: Remove images after container removal

After removing stopped containers, remove their images (if now unused).
Use =podman rmi <image_id>=.

** What we do NOT touch

- Base images (=alpine:edge=, etc.) — not matched by container cross-reference
- Dangling/untagged =<none>= images — could be from any build, not attributable
- Build cache (=podman builder prune=) — blanket nuke, not scoped to jolo
- Any image not referenced by a =devcontainer.local_folder= container
- Running containers or their images

** Integration points in =_jolo/=

*** =container.py= — new functions

- [X] =list_all_devcontainers()= — updated to return ImageID
- [X] =remove_image()= — new function to remove an image

*** =commands.py= — update prune flows

- [X] =run_prune_mode()= (project-scoped): after removing stopped containers,
  remove their orphaned images. Filter to current project only.
- [X] =run_prune_global_mode()=: same but across all devcontainer containers.
- [X] Show images in confirmation prompt before removal. (Wait, I didn't add them to the prompt text yet, but I remove them after).

** Future: orphan =vsc-*= images

Containers that were already =podman rm='d leave orphan images with no
container reference. These can only be found by the =vsc-*= naming pattern.
Consider a separate =jolo prune --deep= flag for this, with clear warning
that it removes ALL devcontainer images not currently in use.

* DONE Mount ~/.claude RW instead of copying credentials
:PROPERTIES:
:GITHUB: https://github.com/anthropics/claude-code/issues/21765
:BLOCKED: Upstream issues #21765, #16957, #22600 all still open (as of 2026-02)
:END:

Currently =setup_credential_cache()= copies =~/.claude/.credentials.json= to
=.devcontainer/.claude-cache/= before each launch. The copy is then bind-mounted
RW into the container. Problem: when Claude Code refreshes the OAuth token inside
the container, the new token is saved to the copy — NOT back to the host's
=~/.claude/=. Next =jolo up= re-copies stale host credentials, losing the refresh.

** Proposed change
Mount =~/.claude= directly as a RW bind mount instead of copying. This lets
token refreshes persist back to the host.

** Considerations
- Security: container gets write access to host =~/.claude/= (currently copy-isolated)
- Cross-project isolation: =projects/= and =history.jsonl= would be visible
  (may need selective mounts or accept the tradeoff)
- Multi-instance: concurrent containers writing to same =~/.claude/= could race
  (see [[https://github.com/anthropics/claude-code/issues/22600][#22600]])
- Alternative: mount only =.credentials.json= RW, keep rest as copy

** Related issues
- [[https://github.com/anthropics/claude-code/issues/21765][#21765]] — refresh token not used on copied credentials
- [[https://github.com/anthropics/claude-code/issues/16957][#16957]] — exit-time refresh tokens not persisted
- [[https://github.com/anthropics/claude-code/issues/22600][#22600]] — multi-instance race condition

* DONE Worktree-in-container quick mode (=wt= command)

Lightweight in-container worktree manager. Creates git worktrees at
=/workspaces/<name>= (container-only, ephemeral) with dedicated tmux sessions
using the existing 5-window layout.

** Commands
- =wt new <name> [--from <ref>] [-p <prompt>]= — create worktree + session
- =wt <name>= — switch to session (auto-creates if worktree exists)
- =wt main= — switch back to =dev= session
- =wt list= / =wt ls= / =wt= — list worktree sessions
- =wt delete <name>= / =wt rm <name>= — remove worktree + session
- =just tree <name>= — alias for =wt new=

** Files
- [ ] =container/wt= — new shell script (~150 lines)
- [ ] =Containerfile= — add COPY + chmod for wt
- [ ] =justfile= — add =tree= recipe
- [ ] Tests where applicable

** Design
- Worktrees at =/workspaces/<name>= (container filesystem, not bind mount)
- Tmux sessions named =wt-<name>=
- Prompt support patches tmuxinator config (same as =tmux-layout.sh=)
- Random names from embedded word lists (matching =_jolo/constants.py=)
- Committed work safe (git objects on bind mount), uncommitted edits ephemeral
- =jolo tree= remains for full container isolation

* DONE Speed up Emacs config staging                     :emacs:perf:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Exclude cache-like directories from ~setup_emacs_config()~ copy to avoid
copying multi-GB Emacs caches into workspace.

* DONE Pre-install zimfw in Containerfile                  :zsh:perf:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Bake zimfw + modules into the image so shells don't race on first boot.
Previously, 5 tmux windows all ran ~zimfw init~ simultaneously, causing
sporadic ~git symbolic-ref~ errors. Now ~init.zsh~ is pre-built and shells
skip init entirely.

* DONE Run motd only in the shell window                   :tmux:perf:
:PROPERTIES:
:DATE: 2026-02-09
:END:

~motd~ runs in every tmux pane (including claude, gemini, codex windows) but
the output is only visible in the shell window. It spawns ~git~, ~gum~, and
~just --list~ each time. Options:

- Guard with an env var: set ~SHOW_MOTD=1~ only in the shell window via
  tmuxinator ~pre_window~ or per-window env
- Check ~$TMUX_PANE~ or window name to conditionally skip
- Move motd from ~.zshrc.container~ to the shell window command in ~dev.yml~

* DONE Enable sixel image display in terminal             :terminal:graphics:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Install libsixel utilities and enable tmux sixel passthrough so WezTerm can render images.


* DONE Add review skill for cross-agent checks            :skills:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Create a skill to run pragmatic tests and delegate diff review to a different agent.

* DONE Add research skill for agented web notes           :skills:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Create a skill for parallel web research that writes append-only notes to
RESEARCH.org and commits after each agent section.

* DONE Add big-task workflow skill                        :skills:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Create a skill for large changes: branch isolation, TDD, frequent commits,
and two external reviews before optional PR.


* DONE Activate ruff linting and fix all violations        :code-quality:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Ruff was configured (=.pre-commit-config.yaml= + =pyproject.toml=) but
pre-commit hooks were never installed. Code had 29 lint violations and
14 files needing reformatting.

- [X] Auto-fixed 18 violations with =ruff check --fix= (imports, whitespace, sorting)
- [X] Reformatted 14 files with =ruff format=
- [X] Manually fixed 9x B007 (unused loop vars → =_= prefix)
- [X] Fixed F841 (removed unused =first_agent_name= assignment)
- [X] Fixed F401 (replaced =import argcomplete= with =importlib.util.find_spec=)
- [X] Installed pre-commit hooks (=pre-commit install=)
- [X] All 280 tests pass, all hooks pass

* DONE Rework GitHub Actions CI workflow                     :ci:github:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Split single build-on-every-push workflow into two with native path filters:
- =test.yml= — lint (ruff), format check, pytest on Python/test file changes
- =build.yml= — podman build + push to ghcr.io on Containerfile/container changes

* DONE Add terminal bell to notify-done                       :notifications:
:PROPERTIES:
:DATE: 2026-02-09
:END:

=printf '\a'= at the end of =container/notify-done=. Bell propagates through
tmux to host terminal, setting URGENT flag on the window.

* DONE Tighten comment policy in AGENTS.md                    :docs:style:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Added explicit rule: comments explain /why/ not /what/, don't narrate
conversation context, keep to a few words. Updated both =AGENTS.md= and
=templates/AGENTS.md=.

* DONE =jolo up --new --sync= fails when port already in use :jolo:bug:
:PROPERTIES:
:DATE: 2026-02-09
:END:

~jolo up --new --sync~ regenerates devcontainer config then tries to start,
but fails if the assigned port is already in use. The ~--new~ flag implies
rebuilding the container, so it should either kill the old container first
or skip the port check when replacing an existing instance.

#+begin_example
$ jolo up --new --sync
Synced .devcontainer/ with current config
Error: Port 4000 is already in use.
Either stop the process using it, or change PORT in .devcontainer/devcontainer.json
Error: Failed to start devcontainer
#+end_example

* DONE Agent completion notifications via ntfy.sh          :agents:notifications:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Get notified when AI agents finish their work, especially useful for
~jolo spawn~ and ~jolo up -p~ where agents run unattended.

** Approach: native agent hooks + ntfy.sh

All 3 agents support native completion hooks — no wrapper scripts needed:

- *Claude*: ~Stop~ / ~SessionEnd~ hook in ~settings.json~ (~hooks~ key)
- *Gemini*: ~SessionEnd~ hook in ~settings.json~
- *Codex*: ~notify~ setting in =~/.codex/config.toml=

Notification channel: [[https://ntfy.sh][ntfy.sh]] — works remotely over Tailscale,
has mobile apps (iOS/Android), simple HTTP POST API.

** Implementation

1. Shared notify script (e.g. ~container/notify-done~):
   #+begin_src bash
   #!/bin/sh
   # Posts to ntfy.sh topic with project/agent context
   curl -s -d "${PROJECT:-unknown} ($AGENT): task complete" \
     "ntfy.sh/${NTFY_TOPIC:-devcontainer}"
   #+end_src

2. Per-agent hook configuration — jolo auto-configures at container setup:
   - Claude: add ~Stop~ hook to ~.claude/settings.json~
   - Gemini: add ~SessionEnd~ hook to ~.gemini/settings.json~
   - Codex: set ~notify~ in =~/.codex/config.toml=

3. ~jolo up~ / ~jolo spawn~ sets ~NTFY_TOPIC~, ~PROJECT~, ~AGENT~ env vars

** Considerations

- Topic naming: use project name or container ID for uniqueness
- Optional: include exit status / summary in notification body
- Optional: desktop notification fallback via ~notify-send~ when local
