#+TITLE: Security Analysis for Autonomous Agent Execution
#+DESCRIPTION: Practical security assessment - what actually matters vs security theater

* Overview

This document analyzes security for running Claude Code in YOLO mode inside containers. The goal: *maximum usability while understanding real risks*.

Guiding principle: If removing access breaks the tool's usefulness, it's not a security improvement - it's just making the tool worse.

* Risk Assessment

** SAFE: GPG Agent Socket

*** Current State
Only the agent socket is mounted, not the private keys:
#+begin_src
pubring.kbx (readonly)    - public keys only
trustdb.gpg (readonly)    - trust database
S.gpg-agent socket        - communication with host agent
#+end_src

*** Status: Already Secure
Private keys *never enter the container*. Agent can request signatures but cannot extract key material. This is the correct design.

Signing commits as the user is *intended behavior* - the user is directing the work.

- [X] No action needed

** FIXED: Claude Configuration (~/.claude)

*** Current State
Selective mounts (readonly):
#+begin_src
~/.claude/.credentials.json (readonly) - auth tokens
~/.claude/settings.json (readonly)     - user preferences
~/.claude/statsig/ (readonly)          - feature flags (subscription, theme)
#+end_src

Excluded (cross-project isolation):
- =projects/= - per-project memory/instructions
- =history.jsonl= - global command history
- =todos/= - todo lists from other projects

*** Security Benefit
- No cross-project instruction injection
- No global history/memory leakage
- Feature flags work (subscription, theme)
- Auth just works (no setup needed)

- [X] Fixed - selective readonly mounts

** INHERENT: API Keys in Environment

*** Current State
#+begin_src
ANTHROPIC_API_KEY, OPENAI_API_KEY
#+end_src

*** Why This Can't Be "Fixed"
No key = no Claude. This is the service, not a container config issue.

- [X] Required for tool to function

** INHERENT: GitHub CLI Configuration

*** Current State
#+begin_src
source=${localEnv:HOME}/.config/gh (readonly)
#+end_src

*** Why This Is Needed
You want to use =gh= commands - that's why it's mounted. The agent doing =gh pr create= is the feature, not a bug.

Already readonly - agent can't modify the config.

- [X] Required for intended workflow

** INHERENT: Network Access

*** Current State
Full network access, ports 4000-5000 forwarded.

*** Why This Is Needed
- Git push/pull
- API calls to Claude
- Package installation (npm, pip, go get)
- Web dev servers

Disabling network makes the tool nearly useless.

- [X] Required for tool to function

** INHERENT: Git Configuration

*** Current State
#+begin_src
source=${localEnv:HOME}/.gitconfig (readonly)
#+end_src

*** Status: Already Secure
Readonly. Needed for git to work (name, email, signing key).

- [X] Already readonly, required for git

** INHERENT: Workspace Access

*** Current State
Full read/write to project directory.

*** This IS The Point
The entire purpose is editing code. Can't sandbox this without making the tool useless.

Review changes with =git diff= before committing - that's the workflow.

- [X] Required - this is the core function

** SAFE: Sudo with Known Password

*** Current State
#+begin_src dockerfile
ARG USER_PASSWORD=dev123
#+end_src

*** Why This Isn't A Real Risk
With rootless Podman: root inside container ≠ root on host.

You *want* sudo to work - installing packages, modifying system files in the container. Agent having sudo inside the container is fine.

- [X] Not a host security risk with rootless containers

** DONE: Shell History

*** Current State
=.histfile= persisted in =.devcontainer/= (per-project, gitignored).

- [X] Per-project history (no cross-contamination)
- [X] In .devcontainer/ which is gitignored

** FIXED: Emacs Configuration

*** Current State
- =start-emacs.sh= uses a sandbox (yadm worktree) - SAFE
- =jolo.py= mounts both config and cache readonly - SAFE

*** Status
- [X] Config mounted readonly
- [X] Cache mounted readonly
- Changes don't affect host

* Summary

| Resource          | Status   | Reason                                    |
|-------------------+----------+-------------------------------------------|
| GPG Socket        | SAFE     | Private keys never exposed                |
| ~/.claude         | FIXED    | Selective readonly (no projects/history)  |
| API Keys          | INHERENT | Required to use the service               |
| GitHub CLI        | INHERENT | You want gh commands to work              |
| Network           | INHERENT | Required for everything                   |
| Git Config        | SAFE     | Already readonly                          |
| Workspace         | INHERENT | This is the entire point                  |
| Sudo              | SAFE     | Rootless container, not a host risk       |
| Shell History     | DONE     | Per-project in .devcontainer/             |
| Emacs Config      | FIXED    | Config and cache both readonly            |

* Actual Recommendations

** For start-emacs.sh users
Already secure - uses sandbox for Emacs config.

** For jolo.py / devcontainer users
- [X] Current setup is secure for directed use
- [X] ~/.claude limited to credentials+settings (readonly)
- [X] ~/.config/emacs is readonly

** For truly unattended autonomous runs
This is a different threat model. If you're letting the agent run for hours unsupervised:
- Review all changes before pushing
- Consider running in a VM instead of container
- But honestly, if you don't trust it unsupervised, don't run it unsupervised

* What Would Actually Be Dangerous (that we're NOT doing)

For reference, things that would be real security problems:
- Mounting =~/.ssh= (private keys) - we don't do this
- Mounting =~/.gnupg/private-keys-v1.d= - we don't do this
- Mounting =~/.password-store= - we don't do this
- Running as root with =--privileged= - we don't do this
- Mounting host root filesystem - we don't do this

The current setup avoids actual dangerous patterns.

* DONE Emacs config isolation improvements

** Mount structure in devcontainer (updated 2026-02)
#+begin_src
~/.config/emacs (container)      <- .devcontainer/.emacs-config/ (copied, writable)
~/.cache/emacs (container)       <- .devcontainer/.emacs-cache/ (fresh per-container)
~/.cache/emacs/elpaca (container)      <- host ~/.cache/emacs-container/elpaca (read-write)
~/.cache/emacs/tree-sitter (container) <- host ~/.cache/emacs-container/tree-sitter (read-write)
#+end_src

** Key: separate cache from host Emacs
Host runs Emacs 31 (glibc/Arch), container runs 30.2 (musl/Alpine).
.elc files and native .so modules are NOT cross-compatible.
=~/.cache/emacs-container/= is a separate persistent cache that elpaca builds
into on first boot. Subsequent boots reuse it.

** DONE Implementation
- [X] Config copied to .devcontainer/.emacs-config/ (writable, isolated)
- [X] elpaca/tree-sitter mounted from ~/.cache/emacs-container/ (read-write, shared)
- [X] setup_emacs_config() creates container cache dirs on host
- [X] Containerfile includes enchant2-dev for jinx-mod.so compilation
- [X] Containerfile includes aspell-en + hunspell-en-us for dictionaries

* DONE Add --mount and --copy options to jolo.py [5/5]

** DONE Add argument parsing for --mount and --copy
- [ ] Add =--mount= argument (action=append for multiple)
- [ ] Add =--copy= argument (action=append for multiple)
- [ ] Both default to empty list =[]= when not provided
- [ ] Test: single --mount, multiple --mount
- [ ] Test: single --copy, multiple --copy
- [ ] Test: --mount and --copy combined

** DONE Implement parse_mount() function
Parse mount argument string into structured data.

*** Syntax
- =source:target= - relative target, read-write
- =source:target:ro= - relative target, read-only
- =source:/absolute/target= - absolute target
- =source:/absolute/target:ro= - absolute target, read-only

*** Logic
- Expand =~= in source path to home directory
- If target starts with =/=, use as-is (absolute)
- If target is relative, prepend =/workspaces/<project>/=
- Default to read-write unless =:ro= suffix
- Return dict: ={source, target, readonly}=

*** Tests
- [ ] Relative target resolves to workspace
- [ ] Absolute target used as-is
- [ ] =:ro= suffix sets readonly=True
- [ ] Default readonly=False
- [ ] Tilde expansion in source

** DONE Implement parse_copy() function
Parse copy argument string into structured data.

*** Syntax
- =source:target= - copy to target path
- =source= - copy to workspace with original basename

*** Logic
- Expand =~= in source path
- If no target specified, use basename of source
- If target is relative, resolve relative to workspace
- If target is absolute, use as-is (but note: only workspace-relative will work)
- Return dict: ={source, target}=

*** Tests
- [ ] With target: resolves correctly
- [ ] Without target: uses basename
- [ ] Relative target resolves to workspace
- [ ] Absolute target used as-is
- [ ] Tilde expansion in source

** DONE Integrate mounts into devcontainer.json generation
- [ ] Create =add_user_mounts()= function (read-modify-write pattern)
- [ ] Format mounts as devcontainer syntax: =source=...,target=...,type=bind[,readonly]=
- [ ] Similar pattern to existing =add_worktree_git_mount()=

*** Persistence behavior
- Mounts added to devcontainer.json persist across restarts
- =--sync= regenerates from BASE_MOUNTS only (clears custom mounts)
- User can manually edit devcontainer.json

*** Tests
- [ ] Mount added to mounts array in JSON
- [ ] Readonly mount includes =readonly= in mount string
- [ ] Multiple mounts all added
- [ ] Verify correct devcontainer mount format

** DONE Implement file copying for --copy
- [ ] Copy files before =devcontainer_up()= is called
- [ ] Handle missing source file (error with clear message)
- [ ] Create parent directories if needed
- [ ] Copied files persist in workspace

*** Integration points
- =run_default_mode()=
- =run_tree_mode()=
- =run_create_mode()=
- =run_init_mode()=

*** Tests
- [ ] File copied to correct location
- [ ] Parent directories created
- [ ] Error on missing source
- [ ] Multiple copies work

** Design decisions

*** Per-invocation vs persistent
- Mounts: persist in devcontainer.json until --sync
- Copies: persist in workspace until deleted

*** Mount syntax mirrors devcontainer
#+begin_example
jolo --mount ~/data:data        # /workspaces/<proj>/data (rw)
jolo --mount ~/data:data:ro     # /workspaces/<proj>/data (ro)
jolo --mount ~/data:/mnt/data   # /mnt/data (rw)
#+end_example

*** Copy syntax similar to mount
#+begin_example
jolo --copy ~/config.json:config/app.json   # /workspaces/<proj>/config/app.json
jolo --copy ~/config.json                   # /workspaces/<proj>/config.json
#+end_example

*** Absolute paths for copy
Copies to absolute paths outside workspace won't work with current approach
(copy happens before container start, workspace is what gets mounted).
Practical restriction: --copy targets should be workspace-relative.

** Test additions for test_jolo.py

*** TestMountArgParsing
- test_mount_flag_single
- test_mount_flag_multiple
- test_mount_default_empty

*** TestMountParsing
- test_parse_mount_relative_target
- test_parse_mount_absolute_target
- test_parse_mount_readonly
- test_parse_mount_expands_tilde
- test_parse_mount_default_readwrite

*** TestCopyArgParsing
- test_copy_flag_single
- test_copy_flag_multiple
- test_copy_default_empty

*** TestCopyParsing
- test_parse_copy_with_target
- test_parse_copy_basename_only
- test_parse_copy_absolute_target
- test_parse_copy_expands_tilde

*** TestMountAndCopyTogether
- test_mount_and_copy_combined

*** TestMountIntegration
- test_add_user_mounts_to_devcontainer_json
- test_mount_readonly_format
- test_multiple_mounts_in_json

* DONE Smart MOTD on every new shell session

Display useful context every time a new tmux pane/window opens (i.e., every new interactive zsh).

** Mechanism
Add a line to =.zshrc.container= (in Containerfile) that runs a motd script.
Every new tmux pane spawns a fresh interactive zsh -> sources .zshrc -> shows motd.

** What to show (dynamic, context-aware)
- Project name (from workspace dir or git remote)
- Git branch + short status
- If justfile exists: =just --list= (the project's available commands)
- If no justfile: container-level info (available tools, tips)
- Port info (=$PORT= value, useful in spawn mode)
- Maybe: last commit summary (one-liner)

** Implementation
- [ ] Create =/usr/local/bin/motd= script in container (or bake into Containerfile)
- [ ] Add =motd= call to =.zshrc.container=
- [ ] Keep output compact - aim for ~5-10 lines max
- [ ] Use color/formatting (gum?) for readability
- [ ] Graceful fallback: if not in a project dir, show generic container info

** Open questions
- Should it suppress in non-interactive contexts? (probably automatic via .zshrc)
- Use =gum= for formatting? (already installed in container)
- Should jolo be able to inject project-specific motd content?

* DONE Prefix container names with project name

Added =--name= to =runArgs= in =build_devcontainer_json()=. Container names in
=podman ps= now match the =name= field: =myapp= for main repo, =myapp-bold-bear=
for worktrees (via =get_container_name()= which already prefixed).

* DONE Rename =jolo switch= to =jolo open=

* DONE Add interactive project switcher to jolo

Implemented as =jolo open=. Uses fzf > gum > numbered fallback.
Filters out orphan containers (missing workspace dir). Skips picker
when only one container is running.

** Requirements
- [X] =jolo open= lists all active/running jolo projects
- [X] Display useful info per project (name, status, worktree, port, container state)
- [X] Interactive selection to switch into the chosen project's container
- [X] Reuse existing =--list= discovery logic for finding active projects

** Design decisions
- Selection UI: fzf > gum > numbered fallback
- "Switch" means: tmux attach into the selected container
- Only show running containers (stopped ones aren't switchable)
- Orphan containers (workspace dir deleted) silently filtered out
- =jolo prune= cleans up orphan containers

* DONE Agent Skills open standard with =.agents/skills/=

Implemented the Agent Skills open standard. Skills live in =.agents/skills/<name>/SKILL.md=
with YAML frontmatter (name, description). Agent-specific directories use symlinks:
- =.claude/skills= -> =../.agents/skills=
- =.gemini/skills= -> =../.agents/skills=

This way skills are written once and discovered by any agent that supports the convention.

** Skills included
- =/afk= — autonomous multi-branch work while user is away
- =/db-reset= — detect and reset local dev database
- =/deploy-preview= — build, test, push preview branch, create draft PR
- =/new-worktree= — create git worktree + devcontainer with naming conventions
- =/scaffold-api= — scaffold FastAPI or Elysia API project
- =/scaffold-web= — scaffold Vite + Tailwind frontend project
- =/sync-dotfiles= — sync yadm dotfiles into container Emacs sandbox

** Structure
#+begin_example
.agents/skills/<name>/SKILL.md   # canonical location
.claude/skills -> ../.agents/skills  # Claude Code symlink
.gemini/skills -> ../.agents/skills  # Gemini CLI symlink
templates/.agents/skills/.gitkeep    # scaffolded into new projects
templates/.claude/skills -> symlink  # scaffolded into new projects
templates/.gemini/skills -> symlink  # scaffolded into new projects
#+end_example

* DONE Unified =jolo delete= — worktree and project removal

Replaced separate =jolo delete= (worktrees only) and =jolo destroy= (projects only)
with a single =jolo delete= that handles both. =jolo destroy= removed.

** What was built
- [X] =jolo delete= — interactive picker showing all projects and worktrees globally
- [X] =jolo delete <name>= — delete worktree by name in current project
- [X] =jolo delete <path>= — delete project by path (starts with =.= or =/=)
- [X] =--purge= flag to also remove directories from disk
- [X] =--yes= / =-y= to skip confirmation prompts
- [X] Interactive selection via fzf > numbered fallback
- [X] Confirmation before each destructive action
- [X] If project has worktrees, prompts to delete them too

** Also fixed
- [X] Worktree port conflicts: new worktrees get fresh random port instead of copying main project's
- [X] Per-command CLI flags: each subcommand only shows its relevant flags in =--help=

* DONE Tmux session layout — auto-start emacs + AI agents (tmuxinator-style)

Uses tmuxinator (=apk add tmuxinator=, pulls in Ruby) with =container/dev.yml=.
Layout script =container/tmux-layout.sh= handles reattach and prompt mode.

** Layout (5 windows, base-index 1)
- Window 1: Emacs (=e=)
- Window 2: Claude Code (=claude --dangerously-skip-permissions=)
- Window 3: Gemini CLI (=gemini --yolo=)
- Window 4: Codex CLI (=codex=)
- Window 5: Spare shell

** Prompt mode
=jolo start -p "..."= writes =.devcontainer/.agent-prompt= and =.agent-name=
before =devcontainer_up()=. =tmux-layout.sh= reads these, patches the
tmuxinator config, and focuses the prompted agent's window.

** Implementation
- [X] =container/dev.yml= — tmuxinator config
- [X] =container/tmux-layout.sh= — wrapper (reattach + prompt)
- [X] =Containerfile= — ruby, tmuxinator, base-index 1, COPY files
- [X] =entrypoint.sh= — =sleep infinity= (devcontainer exec handles tmux)
- [X] =jolo.py= — =write_prompt_file()=, fallback in =devcontainer_exec_tmux()=
- [X] =templates/.gitignore= — =.agent-prompt=, =.agent-name=

* DONE Add a justfile for the jolo meta-project

Already in place with recipes: =test=, =test-k=, =test-v=, =lint=, =lint-fix=,
=fmt=, =fmt-check=, =check= (all three), =build= (container image).

* DONE Coding style conventions for AI agents

Added "Coding Style" section to =templates/AGENTS.md= so every =jolo create=
project gets it. Covers: functional style, strict types, short-but-clear naming,
file size guidelines, language-idiomatic error handling, self-documenting code,
balanced testing, dependency philosophy, and anti-patterns to avoid.

* DONE Tmux copy to host clipboard does not work

Two problems found and fixed:

1. *Host tmux.conf overrides container's* — =BASE_MOUNTS= bind-mounts the host's
   =~/.tmux.conf= (readonly) over the container's, so the Containerfile's clipboard
   settings were silently lost.

2. *=copy-command "wl-copy"= is wrong for containers* — =wl-copy= requires a working
   Wayland connection. In terminal-only jolo devcontainers, Wayland is unreliable.
   OSC 52 (=set -s set-clipboard on=) is the correct mechanism: tmux emits escape
   sequences that the host terminal interprets and copies to the system clipboard.

** Fix
- Added =/etc/tmux.conf= with =set -s set-clipboard on=. The system-wide config is
  loaded *in addition to* the user config, so it survives the host's =~/.tmux.conf=
  being mounted over the container's.
- Removed =copy-command "wl-copy"= from the Containerfile's =~/.tmux.conf=.
  OSC 52 handles clipboard transfer without needing Wayland access.
