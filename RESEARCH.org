#+TITLE: Research Notes
#+STARTUP: overview

* Gemini CLI crashes on Alpine/musl                        :musl:nodejs:gemini:
:PROPERTIES:
:DATE: 2026-02-09
:END:

node-pty prebuilt binary segfaults during PTY cleanup on musl libc.
The command itself executes fine — crash happens on PTY destroy/resize after exit.

** Root cause

~@lydell/node-pty-linux-x64/pty.node~ is compiled against glibc.
~ldd~ shows missing symbols: ~__asprintf_chk~, ~fcntl64~ (glibc-specific),
plus ~napi_*~ symbols (resolved by Node at runtime, not an issue).

~gcompat~ makes the binary loadable but ~forkpty()~ still segfaults
at the native level during cleanup — uncatchable by JS try/catch.

** Fix

Set ~tools.shell.enableInteractiveShell: false~ in ~settings.json~.
This bypasses node-pty entirely and uses ~child_process.spawn()~ fallback
(see ~shellExecutionService.js:86-99~).

Applied in ~_jolo/setup.py:setup_credential_cache()~ — merges the setting
into gemini's settings.json when copying credentials to container.

** Key files

- ~_jolo/setup.py~ — merges ~enableInteractiveShell: false~ after credential copy
- ~Containerfile~ — ~procps~ (GNU pgrep), ~diffutils~ (GNU diff for apheleia)
- Gemini source: ~shellExecutionService.js~, ~getPty.js~, ~shell-utils.js~

** Refs

- https://github.com/google-gemini/gemini-cli/issues/14087 (Alpine crash, open)
- https://github.com/google-gemini/gemini-cli/issues/4676 (Alpine shell hang)
- https://github.com/google-gemini/gemini-cli/issues/3448 (bash not found)

** What ~enableInteractiveShell: false~ loses

- Color output (stripped to plain text)
- Interactive programs (vim, less) don't work in shell tool
- ~isatty()~ returns false

None of this matters for AI agent usage in YOLO mode.

* BusyBox vs GNU tools in Alpine container                 :alpine:busybox:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Alpine ships BusyBox which lacks many GNU flags. Tools that break:

| Tool | Missing flag | Fix package |
|------+--------------+-------------|
| pgrep | ~-g~ (process group) | ~procps~ |
| diff | ~--rcs~, ~--strip-trailing-cr~, ~--text~ | ~diffutils~ |

Emacs apheleia uses ~diff --rcs~ for formatting patches — fails silently
with BusyBox, shows "Output file descriptor of apheleia-diff is closed".

* OAuth token expiration in devcontainers              :oauth:claude:credentials:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Claude Code OAuth tokens expire multiple times per day in jolo devcontainers.

** Root cause

=setup_credential_cache()= copies =~/.claude/.credentials.json= to
=.devcontainer/.claude-cache/= at launch. The copy is bind-mounted RW into
the container. When Claude Code refreshes the token inside the container,
the new token writes to the copy — NOT back to host =~/.claude/=.
Next =jolo up= overwrites the refreshed token with stale host credentials.

Additionally, Claude Code has bugs where it doesn't actually use the refresh
token in several scenarios (copied creds, multi-instance, exit/restart).

** Proposed fix

Mount =~/.claude/.credentials.json= directly RW instead of copying.
Or mount all of =~/.claude= RW (but this exposes =projects/=, =history.jsonl=).

** Open issues (anthropics/claude-code)

- [[https://github.com/anthropics/claude-code/issues/21765][#21765]] — refresh token not used on copied credentials (thumbs-upped, subscribed)
- [[https://github.com/anthropics/claude-code/issues/16957][#16957]] — exit-time refresh tokens not persisted
- [[https://github.com/anthropics/claude-code/issues/22600][#22600]] — multi-instance race condition
- [[https://github.com/anthropics/claude-code/issues/22602][#22602]] — VS Code reuses expired tokens across windows

* Generated project docs layout                             :templates:structure:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Moved =TODO.org= and =RESEARCH.org= from project root to =docs/= for
generated projects. Keeps root clean for code files.

** Changes made

- =templates/TODO.org= -> =templates/docs/TODO.org=
- Created =templates/docs/RESEARCH.org=
- =templates/AGENTS.md= updated to reference =docs/= paths
- =_jolo/setup.py:copy_template_files()= now copies =docs/= as template dir
- Meta-project keeps its own TODO.org and RESEARCH.org at root

* jolo create slowness from Emacs cache copy             :emacs:perf:jolo:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Observed ~jolo create~ taking ~40s while ~devcontainer up~ is ~2s and
~podman run~ is ~0.5s.

** Root cause
Emacs cache (~/.cache/emacs) was being copied as part of Emacs config staging.
Cache size was ~4.2G. Copy dominates runtime even if config itself is small.

** Fix
Exclude cache-like directories during Emacs config copy (e.g. elpaca/straight/elpa,
eln-cache, tree-sitter, auto-save-list, tramp, server). Keep caches in
~/.cache/emacs-container~ bind mounts instead of copying into workspace.

** Evidence
~rsync~ of ~~/.config/emacs~ alone is ~0.05s, while cache size is ~4.2G.

** Key files
- ~_jolo/setup.py~ (setup_emacs_config ignore patterns)

* Eliminate per-project Dockerfile and devcontainer exec overhead :performance:jolo:podman:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Additional startup optimizations beyond the emacs cache fix.

** Per-project Dockerfile eliminated

Each project generated a Dockerfile (~FROM emacs-gui~ + ~apk add nodejs npm~ +
user label). The devcontainer CLI ran two builds (features layer + UID remap)
on every launch even when cached. Switched to ~"image"~ in devcontainer.json
with ~"updateRemoteUserUID": false~. ~DOCKERFILE_TEMPLATE~ constant removed.

** Direct podman exec instead of devcontainer CLI

Every ~devcontainer exec~ spawns Node.js, parses config, resolves features.
- ~is_container_running()~ now uses ~podman ps --filter~ directly
- ~_runtime_exec()~ helper tries ~podman exec~ first, falls back to devcontainer CLI
- Init commands batched into single exec with ~&&~

** GPG keyserver fetch removed from entrypoint

~gpg --keyserver keys.openpgp.org --recv-keys~ ran on every boot. Public keyring
already mounted read-only from host — fetch was redundant and caused variable
3s-2min delays depending on network.

** devcontainer CLI post-start delays (Arch Linux + podman)

Research found three CLI-side delays worth investigating if startup is still slow:
- ~updateRemoteUserUID~ CLI default may override JSON setting
  (use ~--update-remote-user-uid-default never~)
- ~userEnvProbe~ runs interactive login shell with 10s timeout
  (set ~"userEnvProbe": "none"~ in devcontainer.json)
- Podman ~events_logger=journald~ on Arch can stall 10-20s
  (set ~events_logger = "file"~ in ~containers.conf~)
- Ref: [[https://github.com/microsoft/vscode-remote-release/issues/7980][vscode-remote-release#7980]] (Arch + podman events hang)

** Rename

~run_default_mode~ renamed to ~run_up_mode~ — ~--help~ is the actual default,
~up~ is the subcommand.

* Zimfw race condition on container startup                :zsh:zimfw:perf:race:
:PROPERTIES:
:DATE: 2026-02-09
:END:

Multiple tmux windows starting simultaneously caused sporadic ~git symbolic-ref~
errors from zimfw.

** Symptoms

#+begin_example
x modules/input: Error during git symbolic-ref. Use zmodule option -z|--frozen...
  fatal: ref refs/remotes/origin/HEAD is not a symbolic ref
#+end_example

Different number of modules fail each time. Started appearing after Emacs config
copy was optimized (faster startup = more concurrent shell inits).

** Root cause

Tmuxinator launches 5 windows (emacs, claude, gemini, codex, shell) simultaneously.
Each window starts zsh, which sources ~.zshrc~. The ~.zshrc~ zimfw bootstrap
(lines 121-138) checks if ~init.zsh~ is older than ~.zimrc~ and runs
~zimfw init -q~ if so. With 5 shells racing, multiple ~zimfw init~ processes
do concurrent git operations on the same module repos under ~~/.zim/modules/~.

The ~pre~ action in ~zimfw.zsh~ (line 877) runs ~git symbolic-ref --short
refs/remotes/origin/HEAD~ on each module. Concurrent git operations on the
same repos corrupt or conflict on the ref files.

** Fix

Bake zimfw into the container image. Added to Containerfile:

#+begin_src dockerfile
COPY --chown=$USERNAME:$USERNAME container/zimrc $HOME/.zimrc
RUN curl -fsSL -o $HOME/.zim/zimfw.zsh --create-dirs \
        https://github.com/zimfw/zimfw/releases/latest/download/zimfw.zsh && \
    zsh -c "ZIM_HOME=$HOME/.zim source $HOME/.zim/zimfw.zsh init -q"
#+end_src

At runtime, ~init.zsh~ is already built and newer than ~.zimrc~, so the
~.zshrc~ check skips init entirely. No git operations, no race.

** What didn't work

- ~on_project_start~ in tmuxinator dev.yml — command was ignored or too late
- ~tmux-layout.sh~ pre-init with ~if [ -f zimfw.zsh ]~ — skipped on first boot
  because zimfw wasn't downloaded yet (it's not in dotfile mounts)

** Key files

- ~Containerfile~ — zimfw download + init at build time
- ~container/zimrc~ — module list baked into image
- ~container/tmux-layout.sh~ — reverted workaround
- ~~/.zshrc~ lines 121-138 — bootstrap code (bind-mounted from host, readonly)
- ~~/.zim/zimfw.zsh~ line 877 — the ~git symbolic-ref~ that races

